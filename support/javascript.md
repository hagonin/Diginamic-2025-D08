![[diginamic_logo_3-02.png]]
- [[#1 Références|1 Références]]
- [[#2 Historique|2 Historique]]
- [[#3 JavaScript Engine|3 JavaScript Engine]]
	- [[#3 JavaScript Engine#3.1 JavaScript Runtime|3.1 JavaScript Runtime]]
- [[#4 Visual Studio Code|4 Visual Studio Code]]
	- [[#4 Visual Studio Code#4.1 Installer un "linter"|4.1 Installer un "linter"]]
	- [[#4 Visual Studio Code#4.2 Nouveau raccourci clavier|4.2 Nouveau raccourci clavier]]
- [[#5 Commentaires|5 Commentaires]]
- [[#6 Variables|6 Variables]]
	- [[#6 Variables#6.1 Nom des variables ou identifiant|6.1 Nom des variables ou identifiant]]
	- [[#6 Variables#6.2 Typage dynamique|6.2 Typage dynamique]]
			- [[#6.2.1.1 Selon vous, qu'affichera le code ci-dessus dans la console ?|6.2.1.1 Selon vous, qu'affichera le code ci-dessus dans la console ?]]
	- [[#6 Variables#6.3 Transtypage|6.3 Transtypage]]
	- [[#6 Variables#6.4 Portée des variables|6.4 Portée des variables]]
			- [[#6.4.1.1 D'aprés vous que va afficher dans la console le code ci-dessus ?|6.4.1.1 D'aprés vous que va afficher dans la console le code ci-dessus ?]]
	- [[#6 Variables#6.5 Const|6.5 Const]]
- [[#7 Instructions, expressions et structures de contrôle|7 Instructions, expressions et structures de contrôle]]
	- [[#7 Instructions, expressions et structures de contrôle#7.1 Instructions|7.1 Instructions]]
		- [[#7.1 Instructions#7.1.1 Les instructions de contrôle du flux|7.1.1 Les instructions de contrôle du flux]]
			- [[#7.1.1 Les instructions de contrôle du flux#7.1.1.1 `Condition if ...else`|7.1.1.1 `Condition if ...else`]]
		- [[#7.1 Instructions#7.1.2 `Bloc`|7.1.2 `Bloc`]]
		- [[#7.1 Instructions#7.1.3 `break`|7.1.3 `break`]]
		- [[#7.1 Instructions#7.1.4 **`continue`**|7.1.4 **`continue`**]]
		- [[#7.1 Instructions#7.1.5 `switch`|7.1.5 `switch`]]
		- [[#7.1 Instructions#7.1.6 `throw`|7.1.6 `throw`]]
		- [[#7.1 Instructions#7.1.7 `try...catch`|7.1.7 `try...catch`]]
		- [[#7.1 Instructions#7.1.8 Déclarations|7.1.8 Déclarations]]
				- [[#7.1.1.1 `Condition if ...else`#7.1.8.1.1 `var`|7.1.8.1.1 `var`]]
				- [[#7.1.1.1 `Condition if ...else`#7.1.8.1.2 `let`|7.1.8.1.2 `let`]]
				- [[#7.1.1.1 `Condition if ...else`#7.1.8.1.3 `const`|7.1.8.1.3 `const`]]
	- [[#7 Instructions, expressions et structures de contrôle#7.2 Fonctions et classes|7.2 Fonctions et classes]]
				- [[#7.1.1.1 `Condition if ...else`#7.2.1.1.1 `function`|7.2.1.1.1 `function`]]
				- [[#7.1.1.1 `Condition if ...else`#7.2.1.1.2 `return`|7.2.1.1.2 `return`]]
				- [[#7.1.1.1 `Condition if ...else`#7.2.1.1.3 `class`|7.2.1.1.3 `class`]]
			- [[#7.1.8 Déclarations#7.2.1.2 Itérations|7.2.1.2 Itérations]]
				- [[#7.2.1.2 Itérations#7.2.1.2.1 `for`|7.2.1.2.1 `for`]]
				- [[#7.2.1.2 Itérations#7.2.1.2.2 `while`|7.2.1.2.2 `while`]]
				- [[#7.2.1.2 Itérations#7.2.1.2.3 `boucle do ... while`|7.2.1.2.3 `boucle do ... while`]]
				- [[#7.2.1.2 Itérations#7.2.1.2.4 `boucle for ... in`|7.2.1.2.4 `boucle for ... in`]]
				- [[#7.2.1.2 Itérations#7.2.1.2.5 Parcours d'un tableau à index avec la boucle for|7.2.1.2.5 Parcours d'un tableau à index avec la boucle for]]
				- [[#7.2.1.2 Itérations#7.2.1.2.6 Parcours d'un tableau à index avec la boucle for ... of|7.2.1.2.6 Parcours d'un tableau à index avec la boucle for ... of]]
	- [[#7 Instructions, expressions et structures de contrôle#7.3 Autres|7.3 Autres]]
				- [[#7.2.1.2 Itérations#7.3.1.1.1 `debugger`|7.3.1.1.1 `debugger`]]
				- [[#7.2.1.2 Itérations#7.3.1.1.2 `export`|7.3.1.1.2 `export`]]
				- [[#7.2.1.2 Itérations#7.3.1.1.3 `import`|7.3.1.1.3 `import`]]
				- [[#7.2.1.2 Itérations#7.3.1.1.4 `label`|7.3.1.1.4 `label`]]
	- [[#7 Instructions, expressions et structures de contrôle#7.4 Expression|7.4 Expression]]
	- [[#7 Instructions, expressions et structures de contrôle#7.5 Expression VS Statement (instructions)|7.5 Expression VS Statement (instructions)]]
	- [[#7 Instructions, expressions et structures de contrôle#7.6 Zoom sur quelques opérateurs remarquables|7.6 Zoom sur quelques opérateurs remarquables]]
				- [[#7.2.1.2 Itérations#7.6.1.1.1 Chaînage optionnel (optional chaining) (?.)|7.6.1.1.1 Chaînage optionnel (optional chaining) (?.)]]
				- [[#7.2.1.2 Itérations#7.6.1.1.2 Opérateur OR (||)|7.6.1.1.2 Opérateur OR (||)]]
				- [[#7.2.1.2 Itérations#7.6.1.1.3 Comparaison|7.6.1.1.3 Comparaison]]
			- [[#7.1.8 Déclarations#7.6.1.2 A votre avis que va afficher le code ci dessus ?|7.6.1.2 A votre avis que va afficher le code ci dessus ?]]
	- [[#7 Instructions, expressions et structures de contrôle#7.7 Voir le détail des autres opérateurs :|7.7 Voir le détail des autres opérateurs :]]
- [[#8 Fonctions|8 Fonctions]]
	- [[#8 Fonctions#8.1 Fonction classique|8.1 Fonction classique]]
	- [[#8 Fonctions#8.2 Paramètres optionnels et valeurs par défaut|8.2 Paramètres optionnels et valeurs par défaut]]
	- [[#8 Fonctions#8.3 Opérateur Rest|8.3 Opérateur Rest]]
	- [[#8 Fonctions#8.4 Hoisting|8.4 Hoisting]]
	- [[#8 Fonctions#8.5 Contexte d'éxécution|8.5 Contexte d'éxécution]]
		- [[#8.5 Contexte d'éxécution#8.5.1 Closure|8.5.1 Closure]]
			- [[#8.5.1 Closure#8.5.1.1 Autre exemple de closure|8.5.1.1 Autre exemple de closure]]
	- [[#8 Fonctions#8.6 Fonction anonyme immédiate|8.6 Fonction anonyme immédiate]]
			- [[#8.5.1 Closure#8.6.1.1 Exercice|8.6.1.1 Exercice]]
	- [[#8 Fonctions#8.7 Arrow function|8.7 Arrow function]]
	- [[#8 Fonctions#8.8 Raccourci de déclaration de méthode dans un objet|8.8 Raccourci de déclaration de méthode dans un objet]]
		- [[#8.8 Raccourci de déclaration de méthode dans un objet#8.8.1 First class citizen|8.8.1 First class citizen]]
		- [[#8.8 Raccourci de déclaration de méthode dans un objet#8.8.2 Higher order function :|8.8.2 Higher order function :]]
		- [[#8.8 Raccourci de déclaration de méthode dans un objet#8.8.3 Fonction pure|8.8.3 Fonction pure]]
		- [[#8.8 Raccourci de déclaration de méthode dans un objet#8.8.4 setTimeout et setInterval|8.8.4 setTimeout et setInterval]]
- [[#9 Objet|9 Objet]]
	- [[#9 Objet#9.1 Qui est "this" ?|9.1 Qui est "this" ?]]
	- [[#9 Objet#9.2 Raccourci pour la création d'objets - depuis ES2015|9.2 Raccourci pour la création d'objets - depuis ES2015]]
	- [[#9 Objet#9.3 Prototype|9.3 Prototype]]
	- [[#9 Objet#9.4 Reprenons l'exemple de code du début de cette page :|9.4 Reprenons l'exemple de code du début de cette page :]]
	- [[#9 Objet#9.5 Exercice 1|9.5 Exercice 1]]
		- [[#9.5 Exercice 1#9.5.1 Class et héritage|9.5.1 Class et héritage]]
	- [[#9 Objet#9.6 Propriétés privées avec getter et setter|9.6 Propriétés privées avec getter et setter]]
	- [[#9 Objet#9.7 Propriétés et méthodes de classe avec le mot clé static|9.7 Propriétés et méthodes de classe avec le mot clé static]]
	- [[#9 Objet#9.8 Objet littéral|9.8 Objet littéral]]
	- [[#9 Objet#9.9 Assignation destructurée avec le spread operator|9.9 Assignation destructurée avec le spread operator]]
	- [[#9 Objet#9.10 Récupérer des informations sur les objets|9.10 Récupérer des informations sur les objets]]
	- [[#9 Objet#9.11 Connaitre les noms des classes dont héritent une instance d'objet|9.11 Connaitre les noms des classes dont héritent une instance d'objet]]
	- [[#9 Objet#9.12 Exercice 2|9.12 Exercice 2]]
	- [[#9 Objet#9.13 Exercice 3|9.13 Exercice 3]]
- [[#10 Tableaux|10 Tableaux]]
	- [[#10 Tableaux#10.1 Créer un tableau et obtenir sa taille|10.1 Créer un tableau et obtenir sa taille]]
	- [[#10 Tableaux#10.2 Accéder (via son index) à un élément du tableau|10.2 Accéder (via son index) à un élément du tableau]]
	- [[#10 Tableaux#10.3 Boucler sur un tableau|10.3 Boucler sur un tableau]]
	- [[#10 Tableaux#10.4 Ajouter à la fin du tableau|10.4 Ajouter à la fin du tableau]]
	- [[#10 Tableaux#10.5 Supprimer le dernier élément du tableau|10.5 Supprimer le dernier élément du tableau]]
	- [[#10 Tableaux#10.6 Supprimer le premier élément du tableau|10.6 Supprimer le premier élément du tableau]]
	- [[#10 Tableaux#10.7 Ajouter au début du tableau|10.7 Ajouter au début du tableau]]
	- [[#10 Tableaux#10.8 Trouver l'index d'un élément dans le tableau en fonction d'une condition|10.8 Trouver l'index d'un élément dans le tableau en fonction d'une condition]]
	- [[#10 Tableaux#10.9 Méthode "map"|10.9 Méthode "map"]]
			- [[#9.5.1 Class et héritage#10.9.1.1 où comment créer un nouveau tableau à partir d'un tableau existant selon une fonction de transformation|10.9.1.1 où comment créer un nouveau tableau à partir d'un tableau existant selon une fonction de transformation]]
		- [[#10.9 Méthode "map"#10.9.2 Méthode "filter"|10.9.2 Méthode "filter"]]
			- [[#10.9.2 Méthode "filter"#10.9.2.1 où comment créer un nouveau tableau à partir d'un tableau existant en filtrant selon une condition|10.9.2.1 où comment créer un nouveau tableau à partir d'un tableau existant en filtrant selon une condition]]
		- [[#10.9 Méthode "map"#10.9.3 Supprimer des éléments à partir d'un index|10.9.3 Supprimer des éléments à partir d'un index]]
	- [[#10 Tableaux#10.10 Copier un tableau|10.10 Copier un tableau]]
	- [[#10 Tableaux#10.11 Trier un tableau|10.11 Trier un tableau]]
			- [[#10.9.3 Supprimer des éléments à partir d'un index#10.11.1.1 Exemple|10.11.1.1 Exemple]]
		- [[#10.11 Trier un tableau#10.11.2 Assignation destructurée avec le rest operator|10.11.2 Assignation destructurée avec le rest operator]]
		- [[#10.11 Trier un tableau#10.11.3 Assignation avec le spread operator|10.11.3 Assignation avec le spread operator]]
	- [[#10 Tableaux#10.12 Exercice 1 : Classer des utilisateurs par age|10.12 Exercice 1 : Classer des utilisateurs par age]]
	- [[#10 Tableaux#10.13 Exercice 2 - Chaînage des méthodes|10.13 Exercice 2 - Chaînage des méthodes]]
	- [[#10 Tableaux#10.14 Exercice 3 - Méthode reduce|10.14 Exercice 3 - Méthode reduce]]
- [[#11 Asynchrone|11 Asynchrone]]
	- [[#11 Asynchrone#11.1 "Fil d'éxécution" ou thread|11.1 "Fil d'éxécution" ou thread]]
- [[#12 Document Object Model (DOM)|12 Document Object Model (DOM)]]
	- [[#12 Document Object Model (DOM)#12.1 Références :|12.1 Références :]]
	- [[#12 Document Object Model (DOM)#12.2 Représentation générique du DOM|12.2 Représentation générique du DOM]]
	- [[#12 Document Object Model (DOM)#12.3 Un exemple de construction du DOM par un navigateur à partir d'un fichier HTML|12.3 Un exemple de construction du DOM par un navigateur à partir d'un fichier HTML]]
	- [[#12 Document Object Model (DOM)#12.4 Héritage des éléments du DOM|12.4 Héritage des éléments du DOM]]
	- [[#12 Document Object Model (DOM)#12.5 Sélection avancée des éléments du DOM|12.5 Sélection avancée des éléments du DOM]]
	- [[#12 Document Object Model (DOM)#12.6 Exercice 1|12.6 Exercice 1]]
	- [[#12 Document Object Model (DOM)#12.7 Exercice 2|12.7 Exercice 2]]
	- [[#12 Document Object Model (DOM)#12.8 Exercice 3|12.8 Exercice 3]]
	- [[#12 Document Object Model (DOM)#12.9 Exercice 4|12.9 Exercice 4]]
		- [[#12.9 Exercice 4#12.9.1 Fonction qui renvoie null en cas d'erreur|12.9.1 Fonction qui renvoie null en cas d'erreur]]
- [[#13 Evénements|13 Evénements]]
	- [[#13 Evénements#13.1 Liste des événements|13.1 Liste des événements]]
	- [[#13 Evénements#13.2 Exemple|13.2 Exemple]]
	- [[#13 Evénements#13.3 Objet événement|13.3 Objet événement]]
		- [[#13.3 Objet événement#13.3.1 Exemple de récupération de l'objet événement|13.3.1 Exemple de récupération de l'objet événement]]
		- [[#13.3 Objet événement#13.3.2 Exemple de passage de 2 paramètres à la fonction qui est déclenchée au click sur h1|13.3.2 Exemple de passage de 2 paramètres à la fonction qui est déclenchée au click sur h1]]
	- [[#13 Evénements#13.4 addEventListener|13.4 addEventListener]]
	- [[#13 Evénements#13.5 Gestion des événements clavier|13.5 Gestion des événements clavier]]
		- [[#13.5 Gestion des événements clavier#13.5.1 Exemple|13.5.1 Exemple]]
	- [[#13 Evénements#13.6 Exercices|13.6 Exercices]]
		- [[#13.6 Exercices#13.6.1 Paragraphes Lorem ipsum|13.6.1 Paragraphes Lorem ipsum]]
		- [[#13.6 Exercices#13.6.2 Liste de tâches|13.6.2 Liste de tâches]]
- [[#14 Modules|14 Modules]]
	- [[#14 Modules#14.1 Exports et imports multiples|14.1 Exports et imports multiples]]
- [[#15 Mode strict|15 Mode strict]]
		- [[#14.1 Exports et imports multiples#15.1.1 2.3 - Executer la requête|15.1.1 2.3 - Executer la requête]]
	- [[#15 Mode strict#15.2 Traitement du résultat d’une requête|15.2 Traitement du résultat d’une requête]]
		- [[#15.2 Traitement du résultat d’une requête#15.2.1 Les propriétés importantes de XMLHttpRequest|15.2.1 Les propriétés importantes de XMLHttpRequest]]
			- [[#15.2.1 Les propriétés importantes de XMLHttpRequest#15.2.1.1 XMLHttpRequest.status|15.2.1.1 XMLHttpRequest.status]]
			- [[#15.2.1 Les propriétés importantes de XMLHttpRequest#15.2.1.2 XMLHttpRequest.statusText|15.2.1.2 XMLHttpRequest.statusText]]
			- [[#15.2.1 Les propriétés importantes de XMLHttpRequest#15.2.1.3 XMLHttpRequest.responseText|15.2.1.3 XMLHttpRequest.responseText]]
		- [[#15.2 Traitement du résultat d’une requête#15.2.2 Testons le résultat de notre requête|15.2.2 Testons le résultat de notre requête]]
	- [[#15 Mode strict#15.3 Création d'une requête asynchrone|15.3 Création d'une requête asynchrone]]
		- [[#15.3 Création d'une requête asynchrone#15.3.1 Instancier XMLHttpRequest|15.3.1 Instancier XMLHttpRequest]]
		- [[#15.3 Création d'une requête asynchrone#15.3.2 Préparons le terrain avec quelques fonctions sympathiques|15.3.2 Préparons le terrain avec quelques fonctions sympathiques]]
			- [[#15.3.2 Préparons le terrain avec quelques fonctions sympathiques#15.3.2.1 Traiter la progression de la requête : XMLHttpRequest.onprogress()|15.3.2.1 Traiter la progression de la requête : XMLHttpRequest.onprogress()]]
			- [[#15.3.2 Préparons le terrain avec quelques fonctions sympathiques#15.3.2.2 Traiter une erreur de la requête : XMLHttpRequest.onerror()|15.3.2.2 Traiter une erreur de la requête : XMLHttpRequest.onerror()]]
			- [[#15.3.2 Préparons le terrain avec quelques fonctions sympathiques#15.3.2.3 Traiter le changement de statut de la requête : XMLHttpRequest.onload()|15.3.2.3 Traiter le changement de statut de la requête : XMLHttpRequest.onload()]]
		- [[#15.3 Création d'une requête asynchrone#15.3.3 Ouvrir la requête asynchrone|15.3.3 Ouvrir la requête asynchrone]]
		- [[#15.3 Création d'une requête asynchrone#15.3.4 Lancement de la requête|15.3.4 Lancement de la requête]]
		- [[#15.3 Création d'une requête asynchrone#15.3.5 Tester si la réponse est bien au format json avec l'objet JSON et la méthode parse|15.3.5 Tester si la réponse est bien au format json avec l'objet JSON et la méthode parse]]
	- [[#15 Mode strict#15.4 Exercices pratiques|15.4 Exercices pratiques]]
		- [[#15.4 Exercices pratiques#15.4.1 Exercice 1 : Afficher le contenu d'une réponse dans un conteneur html|15.4.1 Exercice 1 : Afficher le contenu d'une réponse dans un conteneur html]]
		- [[#15.4 Exercices pratiques#15.4.2 Exercice 2 : Envoyer des données et traiter la réponse|15.4.2 Exercice 2 : Envoyer des données et traiter la réponse]]
- [[#16 Promesse|16 Promesse]]
	- [[#16 Promesse#16.1 Ancienne méthode : via des callback|16.1 Ancienne méthode : via des callback]]
	- [[#16 Promesse#16.2 Avec les promises|16.2 Avec les promises]]
	- [[#16 Promesse#16.3 Le chaînage de promesses|16.3 Le chaînage de promesses]]
	- [[#16 Promesse#16.4 Async et await|16.4 Async et await]]
		- [[#16.4 Async et await#16.4.1 async|16.4.1 async]]
		- [[#16.4 Async et await#16.4.2 await|16.4.2 await]]
		- [[#16.4 Async et await#16.4.3 Exemple de code|16.4.3 Exemple de code]]
- [[#17 Fetch|17 Fetch]]
	- [[#17 Fetch#17.1 Un exemple complet|17.1 Un exemple complet]]
- [[#18 Bonnes pratiques|18 Bonnes pratiques]]
	- [[#18 Bonnes pratiques#18.1 Linter|18.1 Linter]]
	- [[#18 Bonnes pratiques#18.2 Imperative vs functional programming|18.2 Imperative vs functional programming]]
			- [[#16.4.3 Exemple de code#18.2.1.1 Programmation fonctionnelle|18.2.1.1 Programmation fonctionnelle]]
			- [[#16.4.3 Exemple de code#18.2.1.2 Programmation impérative|18.2.1.2 Programmation impérative]]
			- [[#16.4.3 Exemple de code#18.2.1.3 Langages impératifs et processeurs|18.2.1.3 Langages impératifs et processeurs]]
			- [[#16.4.3 Exemple de code#18.2.1.4 Instructions de la base impérative|18.2.1.4 Instructions de la base impérative]]





>valeur de i dans le bloc : 5

>

>exo3.js:9 valeur de j dans le bloc : 12

>

>exo3.js:11 valeur de i dans le contexte d'exécution global : 5

>

>exo3.js:12 Uncaught ReferenceError: j is not defined

>

>at exo3.js:12

>

>(anonymous) @ exo3.js:12

> ```

>

>## Explication

>Bien que i soit définie dans un bloc de code ({}), c'est une variable globale car elle a été définie avec le mot clé var en dehors d'une fonction.

>

>En revanche, j est une varible locale car elle a été définie avec le mot clé let dans un bloc de code. Elle est donc inconnue en dehors de ce bloc de code

> ```
## 6.5 Const
Le mot clé "const" sert à déclarer une constante. Cela veut simplement dire que vous ne pourrez pas réaffecter une nouvelle valeur à votre constante.
Ex :
```js
const x = 11;
x = 10;
``` 
![assignation mémoire](https://coopernet.fr/sites/default/files/inline-images/assignationMemoire.png)





# 12 Document Object Model (DOM)
## 12.1 Références :

- Document : [https://developer.mozilla.org/fr/docs/Web/API/Document](https://developer.mozilla.org/fr/docs/Web/API/Document)
- Node  : [https://developer.mozilla.org/fr/docs/Web/API/Node#m%C3%A9thodes](https://developer.mozilla.org/fr/docs/Web/API/Node#m%C3%A9thodes)
- Element (élément du dom) : [https://developer.mozilla.org/fr/docs/Web/API/Element](https://developer.mozilla.org/fr/docs/Web/API/Element)

Le Document Object Model (DOM) est une interface de programmation pour les documents HTML. Il fournit une page dont des programmes peuvent modifier la structure, son style et son contenu. Cette représentation du document permet de le voir comme un groupe structuré de nœuds et d'objets possédant différentes propriétés et méthodes. Fondamentalement, il relie les pages Web aux scripts ou langages de programmation.

## 12.2 Représentation générique du DOM

![Représentation historique du DOM](https://coopernet.fr/sites/default/files/inline-images/dom.gif)

## 12.3 Un exemple de construction du DOM par un navigateur à partir d'un fichier HTML

![dom](https://coopernet.fr/sites/default/files/inline-images/dom.png)

Il existe de nombreuses méthodes js pour accéder et modifier le DOM. Vous trouverez ci-dessous une sélection des propriétés indispensables à connaître par coeur :

Accéder à un élément en utilisant son identité
```js
const element = document.getElementById("id-de-l-element-html");
```

Supprimer un élément du DOM
```js
element.remove();
```

Créer un élément du DOM (ici une section)
```js
const section = document.createElement("section");
```

Ajouter un élément à l'arbre du document (DOM), ici le body
```js
window.document.body.appendChild(section);
```

Ajouter du texte à un élément du dom (section par exemple)
```js
section.innerText = "Texte à ajouter";
```

Ajouter un attribut (ici l'identité "news à l'élement stocké dans la const section)
```js
section.setAttribute("id","news");
```

Récupérer la valeur d'un attribut 
```js
section.getAttribute("id");
```

## 12.4 Héritage des éléments du DOM

Imaginons que votre page html contienne un balise h2 ayant pour valeur de l'attribut id "h2". Pour récupérer une référence à cet élément du dom, vous pouvez vous y prendre comme ceci :
```js
let h2 = document.getElementById("h2");
```

Si vous êtes curieux, vous pouvez chercher à savoir de quel classe est issu cet élément :

```js
console.log("class de h2 : ", h2.constructor.name);// affiche class de h2 : HTMLHeadingElement
```

Si vous êtes très curieux, vous pouvez remonter la chaîne des prototypes pour savoir exactement de qui h2 hérite :
```js
while (h2) {
  console.log("class de h2 : ", h2.constructor.name);
  // Remonte la chaîne des prototypes
  h2 = Object.getPrototypeOf(h2);
}
```

[En vérifiant dans la documentation de Mozzilla](https://developer.mozilla.org/fr/docs/Web/API/HTMLHeadingElement), vous pouvez en apprende plus sur chacune des interfaces dont héritent les éléments du DOM :

L'interface **`HTMLHeadingElement`** représente les différents éléments d'en-tête [`<h1>` à `<h6>`](https://coopernet.fr/fr/docs/Web/HTML/Element/Heading_Elements). Elle hérite des méthodes et des propriétés de l'interface [`HTMLElement`](https://coopernet.fr/fr/docs/Web/API/HTMLElement).

EventTargetNodeElementHTMLElementHTMLHeadingElement

## 12.5 Sélection avancée des éléments du DOM

[document.querySelector(".open-close > h2")](https://developer.mozilla.org/fr/docs/Web/API/Document/querySelector); permet de récupérer **le premier élément** du DOM qui correspond au sélecteur passé en paramètre

[document.querySelectorAll(".open-close > h2");](https://developer.mozilla.org/fr/docs/Web/API/Document/querySelectorAll) permet de **récupérer un tableau d'éléments** qui correspondent au sélecteur passé en paramètre

[elt.nextElementSibling](https://developer.mozilla.org/fr/docs/Web/API/NonDocumentTypeChildNode/nextElementSibling) : permet de récupérer l'élément suivant l'élément elt

## 12.6 Exercice 1

Retrouvez à quelle interface du DOM appartiennent les propriétés suivantes :

- innerText
- focus
- insertBefore
- innerHTML
- classList
- addEventListener

Profitez-en pour les retenir, elles vous serviront dans votre vie de développeur front-end !

## 12.7 Exercice 2

Créer en js une balise "nav" qui contient 4 boutons avec les textes "Item 1", "Item 2", "Item 3", Item 4". Placez cet élément du dom dans le header.

Faites en sorte que le premier item soit de couleur rouge (utilisez querySelector puis la propriété "style.color").

Utilisez pour cela uniquement du javascript. Ré-utilisez la fonction createMarkup dont voici le code :
```js
/**
   * Crée un élément du dom, lui ajoute du texte, le place comme dernier
   * enfant de parent et ajoute un attribut en utilisant le paramètre attributes
   * @param {String} markup_name 
   * @param {domElement} parent 
   * @param {String} text 
   * @param {Object} attributes
   * @returns domElement
   */
function createMarkup(markupname, parent, text = "", attributes = {}) {
  const markup = document.createElement(markupname);
  markup.textContent = text;
  parent.appendChild(markup);
  for (key in attributes) {
   markup.setAttribute(key, attributes[key]);
  }
  return markup;
}
```

## 12.8 Exercice 3

Améliorez la fonction createMarkup de façon à ce que l'on puisse ajouter plusieurs attributs. Le paramètre attribute sera remplacé par "attributes" et ne sera plus de type "Objet" mais de type "Array".

Pour finir, faites en sorte que cette fonction n'attende qu'un seul paramètre de type "Object"

## 12.9 Exercice 4

Le but de cet exercice est de créer un simple diaporama qui permet de faire défiler des images.

Voici comment agencer votre code :

- Créer une classe Slideshow
- le constructeur de cette classe attend 4 paramètres :
    - nb_images (le nombre d'images que va gérer le slideshow,
    - width (la largeur du slideshow),
    - height (la hauteur du slideshow),
    - speed (la vitesse de changement d'images en millisecondes).
- Dans le constructeur, vous initialisez 5 propriétés :
    - nb_images (number)
    - images (array)
    - width (number)
    - height (number)
    - speed (number)
- puis, toujours dans le constructeur, vous faites appel à trois méthodes
    - feedSs (// remplissage du tableau d'images "images")  
        Pour créer des images (élément du DOM "img"), vous utiliserez la méthode suivante :
        ```js
        createImage = function() {
        	  // création d'une image
	        	  const img = document.createElement("img");
        	  img.setAttribute("src",`https://picsum.photos/${this.width}/${this.height}?id=${Math.random()*1000}`);
        	  return img;
        }
```
        
        
    - render (rendu du slideshow)
    - animateSs(animation du slideshow)
- Pour l'animation, vous serez amené à utiliser soit setTimeout soit setInterval

# Try catch
L'instruction try...catch regroupe des instructions à exécuter et définit une réponse si l'une de ces instructions provoque une exception.
```js
try {
  nonExistentFunction();
} catch (error) {
  console.error(error.message);
}
```

Les exceptions peuvent être levées volontairement (throw) ou involontairement par l'interpréteur js.

Il est également possible de créer sa propre erreur :
```js
throw new Error("oups");
```

L'instruction throw permet de lever une exception définie par l'utilisateur. L'exécution de la fonction courante sera stoppée (les instructions situées après l'instruction throw ne seront pas exécutées) et le contrôle sera passé au premier bloc catch de la pile d'appels. Si aucun bloc catch ne se trouve dans les fonctions de la pile d'appels, le programme sera terminé.

### 12.9.1 Fonction qui renvoie null en cas d'erreur

Il peut parfois être intéressant de faire en sorte qu'une erreur ne stoppe pas l'exécution d'un script mais que la fonction incriminée renvoie null. Ex :
```js
function getI() {
  try {
    return i;
  } catch (error) {
    return null;
  }
}
console.log(`retour de getI`, getI());
```
# 13 Evénements
Les événements permettent de déclencher une fonction après un ... événement ! Il peut s'agir classiquement d'un clic sur un bouton.

## 13.1 Liste des événements

Voici la liste des événements principaux, ainsi que les actions à effectuer pour qu'ils se déclenchent :

|Nom de l'événement|Action pour le déclencher|
|---|---|
|`click`|Cliquer (appuyer puis relâcher) sur l'élément|
|`dblclick`|Double-cliquer sur l'élément|
|`mouseover`|Faire entrer le curseur sur l'élément|
|`mouseout`|Faire sortir le curseur de l'élément|
|`mousedown`|Appuyer (sans relâcher) sur le bouton gauche de la souris sur l'élément|
|`mouseup`|Relâcher le bouton gauche de la souris sur l'élément|
|`mousemove`|Faire déplacer le curseur sur l'élément|
|`keydown`|Appuyer (sans relâcher) sur une touche de clavier sur l'élément|
|`keyup`|Relâcher une touche de clavier sur l'élément|
|`keypress`|Frapper (appuyer puis relâcher) une touche de clavier sur l'élément|
|`focus`|« Cibler » l'élément|
|`blur`|Annuler le « ciblage » de l'élément|
|`change`|Changer la valeur d'un élément spécifique aux formulaires (`input`,`checkbox`, etc.)|
|`input`|Taper un caractère dans un champ de texte|
|`select`|Sélectionner le contenu d'un champ de texte (`input`,`textarea`, etc.)|

## 13.2 Exemple

// gestion de l'événement click sur div1

// Récupération d'un élément du DOM
let h1 = window.document.getElementById("h1");
/**
 * Gestion de l'événement click sur h1
 * On assigne à la propriété "onclick"
 * une méthode appellée lors d'un click sur
 * l'objet en question.
 * Le "this" devient alors l'objet en question
 */
h1.onclick = function() {
  console.log("click sur le h1");
  console.log(this);
};

## 13.3 Objet événement

l'objet événement (qui correspond à l['interface Event](https://developer.mozilla.org/fr/docs/Web/API/Event)) est automatiquement transmis aux gestionnaires d'événements pour fournir des fonctionnalités et des informations supplémentaires. Une interface définit  les méthodes à implémenter, elle permet de définir un contrat : chaque classe implémentant l’interface sera tenue d’implémenter les méthodes de l’interface. [Voir les méthodes et propriétés de l'interface Event](https://developer.mozilla.org/fr/docs/Web/API/Event#Propri.C3.A9t.C3.A9s).

Plusieurs paramètres 

### 13.3.1 Exemple de récupération de l'objet événement
```js
// gestion de l'événement click sur h1
h1.onclick = function(e) {
  console.log("click sur le h1");
  console.log(e.target);
};
```

### 13.3.2 Exemple de passage de 2 paramètres à la fonction qui est déclenchée au click sur h1

```js
h1.onclick = function(e) {
  manageClick(e,"Hello");
};
const manageClick = function(e,j){
  console.log("click sur le h1");
  console.log(e.target);
  console.log(j);
}
```

## 13.4 addEventListener

[Documentation](https://developer.mozilla.org/fr/docs/Web/API/EventTarget/addEventListener) 

La méthode addEventListener présente deux avantages principaux par rapport à l'utilisation de propriétés de type "onclick" :

1. elle permet à un élément du dom d'écouter plusieurs événements de même type
2. elle attend un troisième paramètre qui permet de gérer plus finement les événements

La méthode addEventListener est appelée depuis une cible (un élément du dom en général) et attend trois paramètres :

1. le type d'évenement (click, hover, ...)
2. une fonction à appeler chaque fois que l'événement spécifié dans le premier argument est envoyé à la cible
3. historiquement, le troisième paramètre de addEventListener était un boolean qui indiquait s'il fallait ou non utiliser la "capture". Cette dernière peut être définie comme la [phase déscendante de la propagation de l'événement en opposition à la phase montante ou "bubbling phase"](https://developer.mozilla.org/fr/docs/Web/API/Event/eventPhase) .   
    ![js event capture bubbling](https://coopernet.fr/sites/default/files/inline-images/eventCaptureBubbling.png)  
     [Plutôt que d'ajouter davantage de paramètres à la fonction, le troisième paramètre a été changé en un objet pouvant contenir diverses propriétés définissant les valeurs des options pour configurer le processus de suppression de l'écouteur d'événement.](https://developer.mozilla.org/fr/docs/Web/API/EventTarget/addEventListener#D%C3%A9tection_de_la_prise_en_charge_des_options_en_toute_s%C3%A9curit%C3%A9)

Exemple de code pour démontrer comment la capture peut être utilisée pour intercepter et potentiellement bloquer des événements.

**HTML**

```html
<div id="parent">
  <div id="child">Click me</div>
</div>
```

```js
const parent = document.querySelector("#parent");
const child = document.querySelector("#child");

// Ajout d'une phase de capture descendante au parent
parent.addEventListener(
  "click",
  function(event) {
    console.log("Parent clicked");
    // Empêche l'événement d'atteindre l'enfant
    event.stopPropagation();
  },
  true// option pour la capture (phase descendante) à vrai 
); 

// Ecouteur classique (phase montante) sur l'enfant
child.addEventListener("click", function(event) {
  console.log("Child clicked");
});


```

## 13.5 Gestion des événements clavier

référence : [https://developer.mozilla.org/fr/docs/Web/API/Element/keydown_event](https://developer.mozilla.org/fr/docs/Web/API/Element/keydown_event)

L'événement `keydown` est déclenché lorsque l'utilisatrice ou l'utilisateur appuie sur une touche du clavier.

### 13.5.1 Exemple 

Imaginons que nous ayons une liste d'images cliquables grâce à la fonction addEventListner. La bonne pratique pour rendre cette fonctionnalité accessible sera de :

1. rendre ces images "focusables" via la touche tab
2. donner une alternative à l'événement "click" en utilisant l'événement "keydown" et en vérifiant que c'est bien  la touche "Enter" qui a été la dernière utilisée.

## 13.6 Exercices

### 13.6.1 Paragraphes Lorem ipsum

En js, ajouter un bouton et une section dans le body. Le bouton aura pour intitulé : "Ajouter un paragraphe". Au click sur ce bouton, un nouveau paragraphe sera ajouté comme dernier enfant de la section qui comprendra tous les paragraphes. Chaque paragraphe aura "Lorem ipsum ..." comme texte.

### 13.6.2 Liste de tâches

En js, ajouter un formulaire dans le body comprenant une zone de texte (input) et un bouton "Ajouter une tâche". Au click sur ce bouton, et après avoir renseigné l'input du formulaire  (`<input type="text"> `), une tâche (ex : acheter du pain ) apparaîtra juste sous le formulaire et dans une section. 

Chaque tâche est crée avec la balise section et permettra d'afficher côte à côte :

- l'intitulé de la tâche,
- un bouton pour valider la tâche (cette dernière sera alors barrée, un bouton "invalider" remplace le bouton "valider" et  toute la tâche est déplacée en fin de section qui entoure l'ensemble des tâches
- un bouton pour supprimer la tâche qui déclenchera au click une "pop-up" grâce à la méthode "confirm()"  pour que l'internaute confirme son choix de suppression. En cas de confirmation, la section "tâche" correspondante sera supprimée.

![liste taches](https://coopernet.fr/sites/default/files/inline-images/listeTaches.png)


# 14 Modules

Depuis ES6, on peut gérer les dépendances entre fichiers avec les mots clés "import" et "export"

Ex
```js
export default class Person {
  constructor(name) {
    this.name = name;
  }
  present() {
    console.log("hello, I'm " + this.name);
  }
}
```

  
De cette façon, dans un autre script, on pourra avoir :

```js
import Person from "./Person.js";
const p = new Person("Bob")
```

Attention, il faudra penser à appeler votre js en utilisant l'attribut type="module"
```html
<script type="module" src="test.10-module.js">
```

## 14.1 Exports et imports multiples

Prenons l'exemple d'un fichier consts.js qui définit les deux constantes pi et nb_or :
```js
export const pi = 3.14159265359;
export const nb_or = 1.61803398875;
```

Il existe deux syntaxes pour importer ces constantes :
```js
import { pi, nb_or } from "./consts.js";
console.log("pi : ", pi);
console.log("nb_or : ", nb_or);
```

ou
```js
import * as consts from "./consts.js";
console.log("pi : ", consts.pi);
console.log("nb_or : ", consts.nb_or);
```

Propriétés privées

Imaginons que nous avons besoin d'une function "createStore"  qui permet de créer une propriété state. Imaginons que cette propriété ne doivent pas être accessible en modification directement depuis un autre endroit que la fonction "createStore" elle même.

Voici comment on pourrait s'y prendre :

Fichier store.js
```js
function createStore() {
  let state = 0;
  function getState() {
    return state;
  }
  return {
    getState
  }
}
export default createStore();
```

Fichier main.js
```js
import store from "./store.js";

console.log("store.state : ", store.getState());

Vous constaterez qu'il n'est pas possible de modifier directement la propriété state de store via main.js avec un code du type :

store.state = 5;
```



# XMLHttpRequest

## Synchrone ou Asynchrone ?

Voilà le dilemme ? Mais essayons tout d’abord de comprendre ces termes.

## Synchrone

Une requête synchrone va bloquer le déroulement de l’exécution du code jusqu’à l’obtention d’un code de réponse de la part du serveur et ce quelque soit le résultat de la requête; succès ou échec.

## Asynchrone

Lors d’une requête asynchrone, l’application continuera de d’exécuter votre code. Des écouteurs seront mis en place afin de détecter un changement d’état de la requête et d’agir en conséquence, comme par exemple exécuter une fonction particulière si la requête est terminée ou si cette dernière a échoué.

## L’objet XMLHttpRequest()

### Instancier XMLHttpRequest

Pour réaliser une requête HTTP, nous devons tout d’abord instancier l’objet XMLHttpRequest

```
const req = new XMLHttpRequest();
```

Jusqu’à là, ça va ? Alors continuons...

### Ouvrir la requête

Nous allons utiliser la méthode **open()** de XMLHttpRequest afin de définir la méthode et l’url de notre requête.

```js
 req.open('GET', 'http://www.neore.fr/mon_fichier.txt', false);
```

La méthode accepte 5 arguments dont les 2 premiers sont impératifs :

1. Le type de méthode : GET, POST, PUT, DELETE, etc
2. L’url : l’adresse absolue du fichier concerné.
3. async : (true ou false) afin de préciser si la requête est asynchrone ou non, elle l’est pas défaut.
4. user : Lors d’une connexion nécessitant une authentification, nous pouvons préciser le nom de l’utilisateur
5. password : Lors d’une connexion nécessitant une authentification, nous pouvons préciser le mot de passe

### 15.1.1 2.3 - Executer la requête

Tout est prêt, nous pouvons maintenant envoyer notre requête grâce à la méthode **send()**

```js
req.send(null);
```

Mais pourquoi on met _null_ en argument de cette méthode ?  
En voilà une bonne question ! Et bien XMLHttpRequest peut tout autant recevoir que envoyer des données. Lors de l’envoi de données, avec la méthode POST par exemple, nous passerons les données envoyées en argument de la méthode send().  
Dans le cas présent, nous n’envoyons aucune donnée, donc nous indiquons simplement _null_.

## 15.2 Traitement du résultat d’une requête

### 15.2.1 Les propriétés importantes de XMLHttpRequest

#### 15.2.1.1 XMLHttpRequest.status

La propriété _status_ contient le code de réponse du serveur Http correspondant à la requête que nous avons formulé. Nous pouvons noter quelques codes importants :

- 200 : Tout va bien, requête OK
- 404 : Le fichier demandé n’existe pas... un classique.
- 500 : Erreur d’execution du serveur.. un classique lors d’un problème d’execution de script Php par exemple

C’est cette propriété que nous interrogerons afin de connaitre l'état de notre requête.

#### 15.2.1.2 XMLHttpRequest.statusText

La propriété _statusText_ contient une chaîne de caractères retournée par le serveur pour nous expliquer un peu mieux le code de résultat. Cette chaîne peut contenir des informations pertinentes pour débugger.

#### 15.2.1.3 XMLHttpRequest.responseText

La propriété _responseText_ contient le contenu de la réponse du serveur sous la forme d'une chaîne de caractères.

### 15.2.2 Testons le résultat de notre requête

Notre requête est envoyée et nous attendons donc le résultat...(rappelez vous, nous avons initialisé une requête synchrone).  
Une fois le résultat de la requête reçu nous pouvons tester le status de celle-ci et, si tout va bien, récupérer le contenu de la requête.

```js

if (req.status === 200) {
    // Yeah ! Super, nous avons un code de réponse OK
    // Voyons le contenu de la réponse dans la console :
    console.log(req.responseText);

} else {
    // Crénom d’un vieux mérou, y’a une .ouille dans le potage !
    // Nous n’avons pas eu un code de réponse OK, mais un autre...
    // Voyons ça dans la console
    console.log("Code de réponse :", req.status);

    // Avec un peu plus d’info :
    console.log("Code de réponse :", req.statusText);
}
```

Nous vérifions donc que req.status est bien égal à 200. Dans le cas contraire, nous affichons le code de résultat et un peu plus d'info dans la console.

## 15.3 Création d'une requête asynchrone

### 15.3.1 Instancier XMLHttpRequest

```js
const req = new XMLHttpRequest();
```

Vous voilà en terrain connu maintenant. Bravo !

### 15.3.2 Préparons le terrain avec quelques fonctions sympathiques

#### 15.3.2.1 Traiter la progression de la requête : XMLHttpRequest.onprogress()

Nous allons créer une fonction qui affichera la progression de téléchargement de notre requête.

```js
function maProgression(event) {

    // L'argument event va contenir deux propriétés intéressantes :
    // event.loaded : nous indique la quantité de d'octets téléchargés.
    // event.total : la quantité d'octets totale attendue.
    // Nous affichons ça dans la console.
    // MAIS, MAIS, MAIS !!! Au préalable nous allons vérifier que des données
    // existent sinon nous aurons une belle erreur d'execution.

    if (event.lengthComputable) {
        console.log("Données totales : ", event.total);
        console.log("Données reçues : ", event.loaded);
    } else {
        console.log("Pas de données calculables");
    }
}

req.onprogress = maProgression;
```

#### 15.3.2.2 Traiter une erreur de la requête : XMLHttpRequest.onerror()

Nous allons créer une fonction qui affichera le pourquoi d'une erreur en cas d'erreur.

```js
function monErreur(event) {
    // Cette fonction sera appellée uniquement en cas d'erreur de la requête.
    // Il nous suffit d'indiquer l'erreur dans la console pour en savoir plus.
    console.error("Erreur", event.target.status);
}

req.onerror = monErreur; // Ceci n'est pas un appel direct de la fonction mais bien une référence à la fonction à appeler quand l'événement se produira
```

#### 15.3.2.3 Traiter le changement de statut de la requête : XMLHttpRequest.onload()

Nous allons créer une fonction qui sera executée à chaque changement de statut de la requête. Si nous recevons le code 200, nous pourrons afficher le contenu de la réponse.

```js
function enCours(event) {
    // On teste directement le status de notre instance de XMLHttpRequest
    if (this.status === 200) {
        // Tout baigne, voici le contenu de la réponse
        console.log("Contenu", this.responseText);
    } else {
        // On y est pas encore, voici le statut actuel
        console.log("Statut actuel", this.status, this.statusText);
    }
}

req.onload = enCours;// Ceci n'est pas un appel direct de la fonction mais bien une référence à la fonction à appeler quand l'événement se produira
```

### 15.3.3 Ouvrir la requête asynchrone

```js
 req.open('GET', 'http://www.neore.fr/mon_fichier.txt', true);
```

Nous avons donc défini le dernier argument à _true_ afin de préciser que nous sommes bien en mode asynchrone.

### 15.3.4 Lancement de la requête

```js 
 req.send(null);
```

- pourquoi y'a _null_ comme argument ?  
- Ben mon p'tit Loulou fallait pas roupiller au début du cours, allez, tu relis le début, hop, hop, hop.

### 15.3.5 Tester si la réponse est bien au format json avec l'objet JSON et la méthode parse

try {
  JSON.parse('{}');              // {}
  JSON.parse('true');            // true
  JSON.parse('"toto"');          // "toto"
  JSON.parse('[1, 5, "false"]'); // [1, 5, "false"]
  JSON.parse('null');            // null
} catch (e) {
  console.error("Parsing error:", e); 
}

[cf méthode parse](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/JSON/parse)

## 15.4 Exercices pratiques

### 15.4.1 Exercice 1 : Afficher le contenu d'une réponse dans un conteneur html

**Objectif** : Vous devez traiter XMLHttpRequest.responseText afin de remplir un conteneur _div_ ayant pour _id_ "ma_div".  
Pour cela, vous devrez :

- Créer une div avec l'id demandé dans votre code HTML.
- Instancier XMLHttpRequest
- Créer une requête GET pour l'url : http://www.neore.fr/mon_fichier.txt
- Tester le code de retour de la requête
- Traiter le contenu de la réponse
- Définir le contenu de votre div avec le contenu de la réponse

### 15.4.2 Exercice 2 : Envoyer des données et traiter la réponse

**Objectif** : Vous devrez envoyer des données avec la méthode POST et traiter XMLHttpRequest.responseText afin de remplir un conteneur _div_ ayant pour _id_ "ma_div2".  
Pour cela, vous devrez :

- Créer une div avec l'id demandé dans votre code HTML.
- Instancier XMLHttpRequest
- Créer une requête POST pour l'url : http://www.neore.fr/coucou.php
- Envoyer les données nom=votre_prenom (remplacer votre_prenom par votre vrai prénom
- Tester le code de retour de la requête
- Traiter le contenu de la réponse
- Définir le contenu de votre div avec le contenu de la réponse
# 16 Promesse
  
[Article pour bien comprendre les promesses.](https://frank.taillandier.me/2017/03/23/comprendre-les-promesses-en-javascript/)

L'objet Promise , apparu avec ES2015; est utilisé pour réaliser des traitements de façon asynchrone. Une promesse représente une valeur qui peut être disponible maintenant, dans le futur voire jamais ! 

Une promesse a 3 états : 

- pending (en cours)
- resolve (résolue)
- reject (rejetée)

## 16.1 Ancienne méthode : via des callback

Pour ce premier exemple, j'ai choisi de ne pas utiliser de fonction asynchrone (via setTimeout par exemple) mais  une fonction qui retourne un résultat aléatoire dans le but de simplifier le code et donc l'explication.
```js
function getToken(s, f) {
  if (Math.random() > 0.5) {
    s("XCOE4dod340CEESee7");
  } else f(new Error("Pas plus de token que de beurre à la roulante"));
}

const success = function(msg) {
  console.log(msg);
};

const failure = function(err) {
  console.error(err);
};

getToken(success, failure);
```

## 16.2 Avec les promises

La principale différence réside dans le fait que le résultat, une réussite ou un échec est renvoyé respectivement à la méthode "then" ou à la méthode "catch" :

```js
getToken = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        const token = "qsdfEDLSoie5d8899;dEDd"
        console.log('Token ok');
        resolve(token);// renvoie le résultat à la méthode "then()"
      } else reject(new Error("Pas de chance, vous n'avez pas pu obtenir de token"));// renvoie le résultat à la méthode "catch"
    }, 2000)
  })
}

getToken()
  .then(value => {
    console.log(value);
  })
  .catch(error => {
    console.error("Erreur: ", error.message);
  });
```

## 16.3 Le chaînage de promesses

On peut avoir besoin d'enchaîner les appels de fonction suivant le résultat d'une opération incertaine. Nous simulons ci dessous un processus dans lequel il faut d'abord obtenir un token avant de pouvoir obtenir des infos sur un utilisateur. Il faudra que la méthode "then" renvoie une autre promesse afin de pouvoir les chaîner.

```js
getToken = () => {
  return new Promise((res, rej) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        const token = "qsdfEDLSoie5d8899;dEDd";
        console.log("Token ok");
        res(token);
      } else
        rej(new Error("Pas de chance, vous n'avez pas pu obtenir de token"));
    }, 2000);
  });
};

getUser = token => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        console.log("User ok", token);
        resolve({ id: 1, token: token });
      } else reject(new Error("Pas d'utilisateur"));
    }, 2000);
  });
};

getToken()
  .then(value => {
    console.log("value dans le premier then : ", value);
    // notez ici que "then" doit renvoyer une promesse pour que l'on puisse "chaîner"
    return getUser(value); 
  })
  .then(value => {
    console.log("value dans le deuxième then : ", value);
  })
  .catch(error => {
    console.error("Erreur: ", error.message);
  });
```

## 16.4 Async et await

La déclaration **async function** et le mot clé await sont des « sucres syntaxiques » apparus avec ES2017. Ils permettent de retrouver une syntaxe plus classique et donc plus lisibles. 

### 16.4.1 async

Le mot clé **async** devant une déclaration de fonction la transforme en fonction asynchrone. Elle va retourner une promesse. Si la fonction retourne une valeur qui n’est pas une promesse, elle sera automatiquement comprise dans une promesse.

La promesse sera résolue avec la valeur renvoyée par la fonction asynchrone ou  sera rompue s’il y a une exception non interceptée émise depuis la fonction asynchrone.

### 16.4.2 await

Le mot clé await est valable uniquement au sein de fonctions asynchrones définies avec async.

await interrompt  l’exécution d’une fonction asynchrone tant qu’une promesse n’est pas résolue ou rejetée.

### 16.4.3 Exemple de code

**Exemple 1 : Réutilisons les fonctions getToken et getUser préalablement définies avec async et await :**

```js
async function getTokenUser() {
      try {
        const token = await getToken(); // bloque l'exécution jusqu'à obtention de la réponse de la promesse
        const user = await getUser(token);
        console.log('Token et user : ', token, user);

      } catch (error) {
        console.log('Erreur attrapée : ', error);
      }
  }
  getTokenUser();
```

**Exemple 2 : même fonction en utilisant async et await puis then()**
```js
// Promesse en utilisant async et await
async function getUniversities() {
  try {
    const response = await fetch("http://universities.hipolabs.com/search?country=Italy");
    const universities = await response.json();
    console.log('universités  : ', universities);

  } catch (error) {
    console.error('Erreur attrapée : ', error);
  }

}
// Promesse en utilisant then
function thenGetUniversities() {
  fetch("http://universities.hipolabs.com/search?country=Italy")
  .then(response => {
    return response.json();
  })
  .then(universities => {
    console.log('universités  : ', universities);
  })
  .catch(error => {
    console.error('Erreur attrapée : ', error)
  })
}
```


# 17 Fetch
La méthode fetch() permet de récupérer des ressources à travers le réseau de manière asynchrone.

Elle utilise les "promise". La réponse au "fetch" est un [objet stream](https://streams.spec.whatwg.org/), sur lequel on peut appeler les méthodes json() ou text() qui retournent eux-même une promesse.

Ex :
```js
fetch("https://www.coopernet.fr/session/token")
  .then(function(response) {
    if (response.status !== 200) { // si ça c'est mal passé
      throw new Error("Le serveur n'a pas répondu correctement");
    } else return response.text(); // renvoie une promesse
  })
  .then(function(data) { // data correspond au retour du résolve (ici deux lignes au dessus)
    console.log("Token récupéré : ", data);
  })
  .catch(error => {console.log("Erreur attrapée : ", error)});
```

L'image ci-dessous tente d'expliquer comment les données sont passées de puis la méthode "then" vers une autre méthode "then" ou vers une catpure d'erreur (catch).

![fetch promise](https://coopernet.fr/sites/default/files/inline-images/fetch_promise_1.png)

## 17.1 Un exemple complet

 ```js
 getUsers = (callbackSuccess, callbackFailed) => {
    // création de la requête
    console.log("Dans getUsers de coopernet.");
    return fetch(this.url_server + "memo/users/", {
      // permet d'accepter les cookies ?
      credentials: "same-origin",
      method: "GET",
      headers: {
        "Content-Type": "application/hal+json",
        "X-CSRF-Token": this.token,
        "Authorization": "Basic " + btoa(this.user.uname + ":" + this.user.upwd) // btoa = encodage en base 64
      }
    })
      .then(response => {
        console.log("data reçues dans getUsers avant json() :", response);
        if (response.status === 200) return response.json();
        else throw new Error("Problème de réponse ", response);
      })
      .then(data => {
        console.log("data reçues dans getTerms :", data);
        if (data) {
          // ajout de la propriété "open" à "false" pour tous les termes de
          // niveau 1
          //data.forEach()
          return data;
        } else {
          throw new Error("Problème de data ", data);
        }
      })
      .catch(error => { console.error("Erreur attrapée dans getUsers", error); });
  };
```

## Exercice 1

Utilisez le endpoint de "universities.hipolabs.com" dont voici un exemple :

http://universities.hipolabs.com/search?country=Italy

### Partie 1

- Vous créez un formulaire qui permet de choisir un pays (France, Italie, Espagne, ...)
- A la validation du formulaire, vous utilisez la méthode "fetch" pour interroger l'API.
- Vous stockez les résultats dans une variable univs (array).
- Vous affichez dans l'interface le nombre de résultats.
- A partir de la variable "univs", vous créez des instances de University qui affichent les résumés d'université (Nom, site web) dans une grille bootstrap de 4 colonnes. Chaque résultat est entouré d'une bordure avec des arrondis.

### Partie 2

Une fois le pays choisi, un autre formulaire apparait et permet de "filtrer" les résultas par nom. Par exemple, si vous entrez "montp", vous ne devriez voir plus que les universistés dont le nom contient "montp".

- Attention à gérer les majuscules et minuscules et si vous y arrivez, les accents.
- Faites en sorte que le filtre ne commence qu'après avoir entré au moins 3 caractères
- Faites en sorte que l'on puisse "revenir" en arrière, c'est à dire par exemple, revenir à "mont" si on a entré "montk"
- Utilisez la [méthode includes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes)

## Exercice 2

Inscrivez-vous sur [https://openweathermap.org/](https://openweathermap.org/ "https://openweathermap.org/").

Faites un formulaire afin d'écire le nom de la ville dont vous voulez connaître la météo.

Utilisez cette api https://openweathermap.org/api/geocoding-api afin de recevoir la longitude et latitude de la ville.

Récuperez les données de cette api https://openweathermap.org/current et affichez :

- L'icône.
- Le nom de la ville.
- La description du temps en français.
- Les températures actuelle, minimal et maximal, en celsius.

## Exercice 3 - Mise en place d'un serveur local "json-server"

Références :

- [https://www.npmjs.com/package/json-server](https://www.npmjs.com/package/json-server)
- [https://bobbyhadz.com/blog/npm-command-not-found-json-server](https://bobbyhadz.com/blog/npm-command-not-found-json-server)

Installer json-server
```shell
npm install -g json-server
```

Créer le répertoire json-server **en dehors de votre répertoire où vous allez créer votre application**

Se rendre sur le répertoire (cd json-server)

Lancer le serveur :
```shell
json-server --watch db.json
```

Créer un fichier db.json : 
```json
{
  "tasks": [
    { "id": 1, "label": "Faire le ménage", "done": "false" }
  ]
}
```

Lancer la commande suivante
```shell
npx json-server --watch db.json --port 3000
```

Tester l'url suivante dans votre navigateur: http://localhost:3000/posts

  
Les routes utilisables :

Requête Http    Route  
GET    /posts  
GET    /posts/1  
POST    /posts  
PUT    /posts/1  
PATCH    /posts/1  
DELETE    /posts/1  
Pas besoin de préciser l'id dans le corps de votre requête POST / PUT / PATCH

POST / PUT / PATCH doivent inclure Content-Type: application/json dans leur header de requête.

Exemple de requête GET : 
```js
fetch("http://localhost:3000/posts")
    .then(response => {
      console.log(`response status`, response.status);
      return response.json();
    })
    .then(data => {
      console.log(`data : `, data);
    })
    .catch(error => {
      console.log(`erreur attrapée : `, error);
    })
```
  
Exemple de requête POST : 
```js
fetch("http://localhost:3000/posts",
    {
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      method: "POST",
      body: JSON.stringify({ "title": "Simon", "author": "Yvan" })
    })
    .then(function (res) { console.log(res) })
    .catch(function (res) { console.log(res) })
```

# 18 Bonnes pratiques 
Le texte suivant est une traduction (maison) du [guide de Ryan McDermott](https://github.com/ryanmcdermott/clean-code-javascript)

Ce document s'inspire du livre Clean Code de Robert C. Martin pour l'adapter au JavaScript. C'est un guide pour produire du code lisible, réutilisable et refactorable en JavaScript.

Tous les principes énoncés ici ne doivent pas être strictement suivis et seront encore moins universellement acceptés. Ce sont des lignes directrices et rien de plus, mais ce sont celles codifiées au cours de nombreuses années d'expérience collective par les auteurs de Clean Code.

Notre métier de développeur a un peu plus de 50 ans et nous en apprenons encore beaucoup. Lorsque l'architecture logicielle sera aussi ancienne que l'architecture elle-même, nous aurons peut-être des règles plus difficiles à suivre. Pour l'instant, laissez ces directives servir de référence pour évaluer la qualité du code JavaScript que vous produisez.

Une dernière chose: sachez que ce guide ne fera pas immédiatement de vous un meilleur développeur de logiciels, et travailler avec lui pendant de nombreuses années ne signifie pas que vous ne ferez pas d'erreurs. Chaque morceau de code commence comme un premier brouillon, comme de l'argile humide qui prend sa forme finale. Enfin, nous ciselons les imperfections lorsque nous l'examinons avec nos pairs. Ne soyez pas trop exigeant en vers vous-même pour les premières ébauches à améliorer. Concentrez vous plutôt sur votre code !

## 18.1 Linter

Un "linter" permet de vérifier la qualité du code. Par exemple [ESLint](https://eslint.org/docs/latest/use/getting-started) est un outil permettant d'identifier et de signaler les pattern trouvés dans le code ECMAScript/JavaScript, dans le but de rendre le code plus cohérent et d'éviter les bugs.

[Vérifier si ESLint est activé sur Visual Studio Code.](https://learn.microsoft.com/en-us/visualstudio/javascript/linting-javascript?view=vs-2022)

## 18.2 Imperative vs functional programming

#### 18.2.1.1 Programmation fonctionnelle

Si l'on en croit wikipédia, la programmation fonctionnelle est un paradigme de programmation de type **déclaratif** qui considère le calcul en tant qu'évaluation de fonctions mathématiques.

Comme le changement d'état et la mutation des données ne peuvent pas être représentés par des évaluations de fonctions la programmation fonctionnelle ne les admet pas, au contraire elle met en avant l'application des fonctions, contrairement au modèle de programmation impérative qui met en avant les changements d'état.

Un langage fonctionnel est donc un langage de programmation dont la syntaxe et les caractéristiques encouragent la programmation fonctionnelle. 

La programmation fonctionnelle s'affranchit de façon radicale des effets secondaires (ou effets de bord) en interdisant toute opération d'affectation.

Le paradigme fonctionnel n'utilise pas de machine à états pour décrire un programme, mais un emboîtement de fonctions qui agissent comme des « boîtes noires » que l'on peut imbriquer les unes dans les autres. Chaque boîte possédant plusieurs paramètres en entrée mais une seule sortie, elle ne peut sortir qu'une seule valeur possible pour chaque n-uplet de valeurs présentées en entrée. Ainsi, les fonctions n'introduisent pas d'effets de bord. Un programme est donc une application, au sens mathématique, qui ne donne qu'un seul résultat pour chaque ensemble de valeurs en entrée. Cette façon de penser, très différente de la démarche de la programmation impérative, est l'une des causes principales de la difficulté qu'ont les programmeurs formés aux langages impératifs pour aborder la programmation fonctionnelle. Cependant, elle ne pose généralement pas de difficultés particulières aux débutants qui n'ont jamais été exposés à des langages impératifs. Un avantage important des fonctions sans effet de bord est la facilité que l'on a à les tester unitairement. Par ailleurs, l'usage généralisé d'une gestion de mémoire automatique par l'intermédiaire d'un ramasse-miettes simplifie la tâche du programmeur.

En pratique, pour des raisons d'efficacité, et du fait que certains algorithmes s'expriment aisément avec une machine à états, certains langages fonctionnels autorisent la programmation impérative en permettant de spécifier que certaines variables sont assignables (ou mutables selon la dénomination habituelle), et donc la possibilité d'introduire localement des effets de bord. Ces langages sont regroupés sous le nom de langages fonctionnels impurs.

Les langages dits purement fonctionnels n'autorisent pas la programmation impérative. De fait, ils sont dénués d'effets de bord et protégés contre les problèmes que pose l'**exécution concurrente**. 

La mise en œuvre des langages fonctionnels fait un usage sophistiqué de la pile car, afin de s'affranchir de la nécessité de stocker des données temporaires dans des tableaux, ils font largement appel à la récursivité (fait d'inclure l'appel d'une fonction dans sa propre définition). L'une des multiples techniques pour rendre la compilation de la récursivité plus efficace est une technique dénommée récursion terminale (en anglais : tail-recursion), qui consiste à accumuler les résultats intermédiaires dans une case mémoire de la pile et à la passer en paramètre dans l'appel récursif. Ceci permet d'éviter d'empiler les appels récursifs dans la pile en les remplaçant par une simple succession de sauts. Le code généré par le compilateur est alors similaire à celui généré par une boucle en impératif.

En programmation déclarative, on décrit le quoi, c'est-à-dire le problème. Par exemple, les pages **HTML sont déclaratives** car elles décrivent ce que contient une page (texte, titres, paragraphes, etc.) et non comment les afficher (positionnement, couleurs, polices de caractères…). Alors qu'en programmation impérative (par exemple, avec le C ou Java), on décrit le comment, c'est-à-dire la structure de contrôle correspondant à la solution.

C'est une forme de programmation sans effets de bord, ayant généralement une correspondance avec la logique mathématique.

#### 18.2.1.2 Programmation impérative

Si l'on en croit wikipédia, en informatique, la programmation impérative est un paradigme de programmation qui décrit les opérations en séquences d'instructions exécutées par l'ordinateur pour modifier l'état du programme. Ce type de programmation est le plus répandu parmi l'ensemble des langages de programmation existants, et se différencie de la programmation déclarative (dont la programmation logique ou encore la programmation fonctionnelle sont des sous-ensembles).

#### 18.2.1.3 Langages impératifs et processeurs

La quasi-totalité des processeurs qui équipent les ordinateurs sont de nature impérative : ils sont faits pour exécuter une suite d'instructions élémentaires, codées sous forme d'opcodes (pour operation codes). L'ensemble des opcodes forme le langage machine spécifique à l'architecture du processeur. L'état du programme à un instant donné est défini par le contenu de la mémoire centrale à cet instant.

Les langages de plus haut niveau utilisent des variables et des opérations plus complexes, mais suivent le même paradigme. Les **recettes de cuisine** et les vérifications de processus industriel sont deux exemples de concepts familiers qui s'apparentent à de la programmation impérative ; de ce point de vue, chaque étape est une instruction, et le monde physique constitue l'état modifiable. Puisque les idées de base de la programmation impérative sont à la fois conceptuellement familières et directement intégrées dans l'architecture des microprocesseurs, la grande majorité des langages de programmation est impérative.

#### 18.2.1.4 Instructions de la base impérative  
La plupart des langages de haut niveau comporte cinq types d'instructions principales :

- la séquence d'instructions
- l'assignation ou affectation
- l'instruction conditionnelle
- la boucle
- les branchements

**Séquence d'instructions**  
Une séquence d'instructions, (ou bloc d'instruction) désigne le fait de faire exécuter par la machine une instruction, puis une autre, etc., en séquence. Par exemple

{\displaystyle {\mbox{ouvrirConnexion}};{\mbox{envoyerMessage}};{\mbox{fermerConnexion}};}{\mbox{ouvrirConnexion}};{\mbox{envoyerMessage}};{\mbox{fermerConnexion}};  
est une séquence d'instructions. Cette construction se distingue du fait d'exécuter en parallèle des instructions.

**Instructions d'assignation**  
Les instructions d'assignation, en général, effectuent une opération sur l'information en mémoire et y enregistrent le résultat pour un usage ultérieur. Les langages de haut niveau permettent de plus l'évaluation d'expressions complexes qui peuvent consister en une combinaison d'opérations arithmétiques et d'évaluations de fonctions et l'assignation du résultat en mémoire. Par exemple:

{\displaystyle x\leftarrow 2+3;}x\leftarrow 2+3;  
assigne la valeur {\displaystyle 2+3}2+3, donc 5, à la variable de nom {\displaystyle x}x.

**Instructions conditionnelles**  
Les instructions conditionnelles permettent à un bloc d'instructions de n'être exécuté que si une condition prédéterminée est réalisée. Dans le cas contraire, les instructions sont ignorées et la séquence d'exécution continue à partir de l'instruction qui suit immédiatement la fin du bloc. Par exemple

{\displaystyle si\;{\mbox{connexionOuverte}}\;alors\;{\mbox{envoyerMessage}};}{\displaystyle si\;{\mbox{connexionOuverte}}\;alors\;{\mbox{envoyerMessage}};}  
n'enverra le message que si la connexion est ouverte.

**Instructions de bouclage**  
Les instructions de bouclage servent à répéter une suite d'instructions un nombre prédéfini de fois (voir Boucle_for), ou jusqu'à ce qu'une certaine condition soit réalisée. Par exemple

{\displaystyle tantque\;{\mbox{connexionNonOuverte}}\;alors\;{\mbox{attendreUnPeu}};}tantque\;{\mbox{connexionNonOuverte}}\;alors\;{\mbox{attendreUnPeu}};  
bouclera jusqu'à ce que la connexion soit ouverte.

Il se trouve que ces quatre constructions permettent de faire tous les programmes informatiques possibles, elles permettent de faire un système Turing-complet.

**Branchements sans condition**  
Les branchements sans condition permettent à la séquence d'exécution d'être transférée à un autre endroit du programme. Cela inclut le saut, appelé « goto » (go to, /ɡəʊ tuː/, « aller à ») dans de nombreux langages, et les sous-programmes, ou appels de procédures. Les instructions de bouclage peuvent être vues comme la combinaison d'un branchement conditionnel et d'un saut. Les appels à une fonction ou une procédure (donc un Sous-programme) correspondent à un saut, complété du passage de paramètres, avec un saut en retour.

Exemple de code js utilisant alternativement une approche impérative puis une approche fonctionnelle

```js
// list of my friends
const friends = [
  { name: "Erwin", drinks: ["beer", "coffee"] },
  { name: "Peter", drinks: ["beer"] },
  { name: "Heidi", drinks: ["water"] }
];

// what do we want to search?
const itemToSearch = "beer";

/***********************************
 * imperative approach
 */

// a place to store the results
let resultImperative = [];

// go over every friend
for (friend of friends) {
  // check if the person drinks this
  if (friend.drinks.includes(itemToSearch)) {
    // add it to the results
    resultImperative.push(friend.name);
  }
}
console.log(resultImperative); // [ 'Erwin', 'Peter' ]

/***********************************
 * functional approach
 */
const resultFunctional = friends
  // check if the person drinks this
  .filter(friend => friend.drinks.includes(itemToSearch))
  // only give me the name
  .map(friend => friend.name);
console.log(resultFunctional); // [ 'Erwin', 'Peter' ]
```